Useful code and links from the web. And sometimes a sort of development blog.

= Back to Databases (Apr21, 2010) = 

I have great respect for sqlite3. Solid, well thought out, well tested API.

But I'm just attached to hierarchical data. Curse that XML and it's hierarchical ways...I just can't give it up. I wrote a very simple database that takes advantage that the writer can be slow and use a lot of memory, while the reader needs to be lean and mean. Great exercise, and a nice bit of code on the other side. (gamedb, gamedbwriter, and gamedbreader.) gamedb loads only the part of the file need to index the data and reads the data itself on demand.

= On to Android =

With the license change in the iPhone 4 SDK specifying the source language, Apple has crossed the line from being annoying to draconian. I'm switching development to Android. Hopefully it will go well. 

Android supports both GL:ES1.1 and ES2.0, which I'd like to switch to at some point. (After it's working.) I have a Nexus One for development, which is a great little phone. I'm sure there will be hiccups on the way - the code thus far is very iPhone-centric.

= DB vs. XML vs. Binary = 

Initially, a bunch of serialization (saving/loading) was done with binary files. Binary files are small. That's all I have good to say about them. They are difficult to debug, tool, and version.

Along came sqlite3. sqlite3 is grand - good API, simple, and great tools. You can open up a command line to see what is in the "save files". I probably went a little too gung-ho with sqlite3, just because it was fun to learn and a huge improvement over binary files. It's grand for saving and fetching resources. The resource system will stay in the DB.

But it's hard to represent complex data relationships. I'm sure the DB folks out there know all the tricks, but it's just inconvenient to represent something like a Map, which contains Items, Storage, some Flags, and tagged data. XML is great at that.

XML is super flexible, good tools (you can browse it with IE or Firefox), and represents rich data easily. But it creates huge files relative to the original binary data. However, the game's files are so tiny (<50k) and compress very well (often less that 10k) that I'm switching to it as the primary format for save files.

That's the road so far for serialization. A difficult system to "get right" in the code.

= Code Static analysys =

Run cppcheck and see what it turns up.

= Application data =

Mac Code: wacky NS stuff (already done)

Win Code: SHGetSpecialFolderPath

= Considering SQLite DB =

Considering moving to SQLite for file access, and removing the roll-my-own. The only downside is learning a new API; upside is a way to view and edit the save files, and a solid mechanism for file access.

Nice example of simple (but efficient) SQLite that avoids lots of prints to strings.

{{{
sqlite3* db = NULL;
sqlite3_open("myfile.db", &db);

sqlite3_stmt* stmt = NULL;
sqlite3_prepare_v2(db, "select * from foo where a=? and b=?;", &stmt,
NULL);

sqlite3_bind_int(stmt, 1, 42);
sqlite3_bind_double(stmt, 2, 4.2);

while (sqlite3_step(stmt) == SQLITE_ROW) {
  foo row;
  row.a = sqlite3_column_int(stmt, 0);
  row.b = sqlite3_column_double(stmt, 1);
  row.d = sqlite3_column_bytes(stmt, 2);
  assert(row.d <= sizeof(row.c));
  memcpy(row.c, sqlite3_column_blob(stmt, 2), row.d);

  // do something with row
}

sqlite3_finalize(stmt);
sqlite3_close(db); 
}}}